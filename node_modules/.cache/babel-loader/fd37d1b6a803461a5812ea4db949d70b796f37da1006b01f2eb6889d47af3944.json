{"ast":null,"code":"// ANITA Finance Advisor - Supabase Integration\n// This file provides clean integration with Supabase using MCP\n\n// Transaction operations using MCP Supabase\nexport const saveTransaction = async (transaction, userId) => {\n  try {\n    const insertData = {\n      user_id: userId,\n      type: transaction.type,\n      amount: transaction.amount,\n      category: transaction.category,\n      description: transaction.description,\n      date: transaction.date.toISOString()\n    };\n\n    // Use MCP Supabase to insert transaction\n    const result = await mcp_supabase_execute_sql({\n      query: `\n        INSERT INTO transactions (user_id, type, amount, category, description, date)\n        VALUES ('${insertData.user_id}', '${insertData.type}', ${insertData.amount}, '${insertData.category}', '${insertData.description}', '${insertData.date}')\n        RETURNING *\n      `\n    });\n    return {\n      data: result,\n      error: null\n    };\n  } catch (error) {\n    console.error('Error saving transaction:', error);\n    return {\n      data: null,\n      error\n    };\n  }\n};\nexport const fetchTransactions = async userId => {\n  try {\n    const result = await mcp_supabase_execute_sql({\n      query: `\n        SELECT * FROM transactions \n        WHERE user_id = $1 \n        ORDER BY date DESC\n      `,\n      parameters: [userId]\n    });\n\n    // Transform the data to match our interface\n    const transactions = result.map(row => ({\n      id: row.id.toString(),\n      type: row.type,\n      amount: parseFloat(row.amount),\n      category: row.category,\n      description: row.description,\n      date: new Date(row.date),\n      user_id: row.user_id\n    }));\n    return {\n      data: transactions,\n      error: null\n    };\n  } catch (error) {\n    console.error('Error fetching transactions:', error);\n    return {\n      data: [],\n      error\n    };\n  }\n};\nexport const saveMessage = async (message, userId) => {\n  try {\n    const result = await mcp_supabase_execute_sql({\n      query: `\n        INSERT INTO messages (user_id, content, message_type)\n        VALUES ($1, $2, $3)\n        RETURNING *\n      `,\n      parameters: [userId, message.content, message.message_type]\n    });\n    return {\n      data: result,\n      error: null\n    };\n  } catch (error) {\n    console.error('Error saving message:', error);\n    return {\n      data: null,\n      error\n    };\n  }\n};\nexport const fetchMessages = async userId => {\n  try {\n    const result = await mcp_supabase_execute_sql({\n      query: `\n        SELECT * FROM messages \n        WHERE user_id = $1 \n        ORDER BY created_at ASC\n      `,\n      parameters: [userId]\n    });\n    const messages = result.map(row => ({\n      id: row.id.toString(),\n      content: row.content,\n      message_type: row.message_type,\n      user_id: row.user_id,\n      created_at: new Date(row.created_at)\n    }));\n    return {\n      data: messages,\n      error: null\n    };\n  } catch (error) {\n    console.error('Error fetching messages:', error);\n    return {\n      data: [],\n      error\n    };\n  }\n};\nexport const getOrCreateDefaultUser = async () => {\n  try {\n    // First try to get existing default user\n    const existingUser = await mcp_supabase_execute_sql({\n      query: `\n        SELECT * FROM users \n        WHERE username = 'default_user' \n        LIMIT 1\n      `,\n      parameters: []\n    });\n    if (existingUser && existingUser.length > 0) {\n      return {\n        data: existingUser[0],\n        error: null\n      };\n    }\n\n    // Create new default user if none exists\n    const newUser = await mcp_supabase_execute_sql({\n      query: `\n        INSERT INTO users (username, email, display_name)\n        VALUES ('default_user', 'default@anita.com', 'Default User')\n        RETURNING *\n      `,\n      parameters: []\n    });\n    return {\n      data: newUser[0],\n      error: null\n    };\n  } catch (error) {\n    console.error('Error getting/creating default user:', error);\n    return {\n      data: null,\n      error\n    };\n  }\n};\n\n// Real-time subscription helper\nexport const subscribeToTransactions = (userId, callback) => {\n  // This would be implemented using Supabase real-time subscriptions\n  // For now, we'll return a cleanup function\n  return () => {\n    console.log('Transaction subscription cleanup');\n  };\n};","map":{"version":3,"names":["saveTransaction","transaction","userId","insertData","user_id","type","amount","category","description","date","toISOString","result","mcp_supabase_execute_sql","query","data","error","console","fetchTransactions","parameters","transactions","map","row","id","toString","parseFloat","Date","saveMessage","message","content","message_type","fetchMessages","messages","created_at","getOrCreateDefaultUser","existingUser","length","newUser","subscribeToTransactions","callback","log"],"sources":["C:/Users/dzm13/anita-finance-advisor/src/supabase.ts"],"sourcesContent":["// ANITA Finance Advisor - Supabase Integration\r\n// This file provides clean integration with Supabase using MCP\r\n\r\nexport interface Transaction {\r\n  id?: string;\r\n  type: 'income' | 'expense';\r\n  amount: number;\r\n  category: string;\r\n  description: string;\r\n  date: Date;\r\n  user_id?: string;\r\n}\r\n\r\nexport interface Message {\r\n  id?: string;\r\n  content: string;\r\n  message_type: 'user' | 'bot';\r\n  user_id?: string;\r\n  created_at?: Date;\r\n}\r\n\r\nexport interface User {\r\n  id: string;\r\n  username: string;\r\n  email?: string;\r\n  display_name?: string;\r\n  created_at?: Date;\r\n}\r\n\r\n// Transaction operations using MCP Supabase\r\nexport const saveTransaction = async (transaction: Transaction, userId: string): Promise<{ data: any; error: any }> => {\r\n  try {\r\n    const insertData = {\r\n      user_id: userId,\r\n      type: transaction.type,\r\n      amount: transaction.amount,\r\n      category: transaction.category,\r\n      description: transaction.description,\r\n      date: transaction.date.toISOString()\r\n    };\r\n\r\n    // Use MCP Supabase to insert transaction\r\n    const result = await mcp_supabase_execute_sql({\r\n      query: `\r\n        INSERT INTO transactions (user_id, type, amount, category, description, date)\r\n        VALUES ('${insertData.user_id}', '${insertData.type}', ${insertData.amount}, '${insertData.category}', '${insertData.description}', '${insertData.date}')\r\n        RETURNING *\r\n      `\r\n    });\r\n\r\n    return { data: result, error: null };\r\n  } catch (error) {\r\n    console.error('Error saving transaction:', error);\r\n    return { data: null, error };\r\n  }\r\n};\r\n\r\nexport const fetchTransactions = async (userId: string): Promise<{ data: Transaction[]; error: any }> => {\r\n  try {\r\n    const result = await mcp_supabase_execute_sql({\r\n      query: `\r\n        SELECT * FROM transactions \r\n        WHERE user_id = $1 \r\n        ORDER BY date DESC\r\n      `,\r\n      parameters: [userId]\r\n    });\r\n\r\n    // Transform the data to match our interface\r\n    const transactions = result.map((row: any) => ({\r\n      id: row.id.toString(),\r\n      type: row.type,\r\n      amount: parseFloat(row.amount),\r\n      category: row.category,\r\n      description: row.description,\r\n      date: new Date(row.date),\r\n      user_id: row.user_id\r\n    }));\r\n\r\n    return { data: transactions, error: null };\r\n  } catch (error) {\r\n    console.error('Error fetching transactions:', error);\r\n    return { data: [], error };\r\n  }\r\n};\r\n\r\nexport const saveMessage = async (message: Message, userId: string): Promise<{ data: any; error: any }> => {\r\n  try {\r\n    const result = await mcp_supabase_execute_sql({\r\n      query: `\r\n        INSERT INTO messages (user_id, content, message_type)\r\n        VALUES ($1, $2, $3)\r\n        RETURNING *\r\n      `,\r\n      parameters: [userId, message.content, message.message_type]\r\n    });\r\n\r\n    return { data: result, error: null };\r\n  } catch (error) {\r\n    console.error('Error saving message:', error);\r\n    return { data: null, error };\r\n  }\r\n};\r\n\r\nexport const fetchMessages = async (userId: string): Promise<{ data: Message[]; error: any }> => {\r\n  try {\r\n    const result = await mcp_supabase_execute_sql({\r\n      query: `\r\n        SELECT * FROM messages \r\n        WHERE user_id = $1 \r\n        ORDER BY created_at ASC\r\n      `,\r\n      parameters: [userId]\r\n    });\r\n\r\n    const messages = result.map((row: any) => ({\r\n      id: row.id.toString(),\r\n      content: row.content,\r\n      message_type: row.message_type,\r\n      user_id: row.user_id,\r\n      created_at: new Date(row.created_at)\r\n    }));\r\n\r\n    return { data: messages, error: null };\r\n  } catch (error) {\r\n    console.error('Error fetching messages:', error);\r\n    return { data: [], error };\r\n  }\r\n};\r\n\r\nexport const getOrCreateDefaultUser = async (): Promise<{ data: User; error: any }> => {\r\n  try {\r\n    // First try to get existing default user\r\n    const existingUser = await mcp_supabase_execute_sql({\r\n      query: `\r\n        SELECT * FROM users \r\n        WHERE username = 'default_user' \r\n        LIMIT 1\r\n      `,\r\n      parameters: []\r\n    });\r\n\r\n    if (existingUser && existingUser.length > 0) {\r\n      return { data: existingUser[0], error: null };\r\n    }\r\n\r\n    // Create new default user if none exists\r\n    const newUser = await mcp_supabase_execute_sql({\r\n      query: `\r\n        INSERT INTO users (username, email, display_name)\r\n        VALUES ('default_user', 'default@anita.com', 'Default User')\r\n        RETURNING *\r\n      `,\r\n      parameters: []\r\n    });\r\n\r\n    return { data: newUser[0], error: null };\r\n  } catch (error) {\r\n    console.error('Error getting/creating default user:', error);\r\n    return { data: null, error };\r\n  }\r\n};\r\n\r\n// Real-time subscription helper\r\nexport const subscribeToTransactions = (userId: string, callback: (transaction: Transaction) => void) => {\r\n  // This would be implemented using Supabase real-time subscriptions\r\n  // For now, we'll return a cleanup function\r\n  return () => {\r\n    console.log('Transaction subscription cleanup');\r\n  };\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}